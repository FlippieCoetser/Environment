# R Package Template

This repository can be used a boilerplate when creating a new R package. It contains a basic package structure and a few useful files to get started.

## Getting Started

### Installation

Whether your development environment is based on RStudio or VS Code the installation instructions are the same:

1. R `devtools` is required when developing R packages. Install and Reboot:

```r
install.packages("devtools")
```

2. Install unit the unit testing framework `testthat`:

```r
install.packages("testthat")
```

3. Clone this repository:

```bash
git clone https://github.com/FlippieCoetser/r.template.git
```

## Template Architecture

### Folder Structure

By design R packages leverage a specific folder structure. This structure is used by `devtools` to document, check and build packages.
Here is an overview of the different files and folders that make up the package structure.

Files:

- `DESCRIPTION`: Contains the package metadata. This file is used to define the package name, version, dependencies and other metadata.
- `NAMESPACE`: Contains the package namespace. This file is used to define the package exports and imports.
- `LICENSE`: Contains the package license. This file is used to define the package license.
- `README.md`: Contains the package readme. This file is used to provide a high-level overview of the package.

Folders:

- `man`: Contains the documentation files. These files are generated by `devtools` and should not be edited manually.
- `R`: Contains the R source code files. These files are used to define the functions and data structures that make up the package.
- `tests`: Contains the unit tests. These files are used to test the functions and data structures that make up the package.
- `vignettes`: Contains the vignettes. These files are used to provide additional documentation and examples.

Most of you time spent developing R packages will be spent in the R and Tests folders. Files in both `man` and `vignettes` are generated by `devtools` and should not be edited manually. Also the contents in the `NAMESPACE` file should not be edited manually.

### Structural Decomposition

In a typical enterprise-level software, we often see a pyramid-like hierarchy. At the very top of this hierarchy, we have the application itself.

![Enterprise Application Hierarchy](/man/figures/Architecture.png)

- Beneath the application, we find `Packages`. These are frameworks or subsets of functionality that build upon and extend the core application. Most programming languages supports packages. By using packages, we can reuse functionality across multiple applications. For example in R, there is a popular package called `dplyr`. This package make is easy to manipulate data and is used in many applications. A section on packages will follow towards the end of this article.

- Further down, within each Package, we have `Modules`. a module is used to group related or complimentary components. Both Javascript and C# have builtin features and syntax that can be used to create modules. R does not have specific syntax to create modules. By using the `dot.case` naming convention the identification and encapsulation of modules can be achieved in R, essentially imitating namespacing as available in other languages.

- Second to last, we have the `Components` themselves. These are the individual units of functionality. Most object-oriented programming languages uses classes to create components. In R, components are typically created using a combinations of functions and data structures. Advanced R users may also use S3 or S4 classes or create new local environments. Also, by following a Data-Oriented programming paradigm components can be simplified.

- At the base of the hierarchy, we have component `Members`, the individual units of data (Properties) or logic (Methods). Again, most object-oriented programming language include specific keywords to control the access of component members. In R we will leverage different data structures to achieve a similar result.

## Encapsulation

The process of establishing clear boundaries between layers is called encapsulation. Encapsulation is a key concept in software engineering. It is used to reduce complexity and increase reusability. When developing enterprise level applications, it is important to establish boundaries between the different layers.

Depending on both the programming paradigm you intent to follow and the features of a particular programming language or framework, the boundaries between these layers may be:

1. Well-defined
2. Blurred
3. Non-existing

You already come across encapsulation when we discussed the Shiny application framework with the customer shiny todo application. However, from a structural perspective the boundaries between the layers: `Packages - Modules`, `Modules - Components` and `Components - Variables`, are not well defined in R. In fact, with the exception of `Packages`, all layers: `Modules`, `Components` and component `Members` are declared and assigned to `Variables`. This is not the case in Javascript or C#. But, there is a reason for this: Flexibility and Expressiveness.

The table below provides a high-level comparison of the different layers and explicit languages features used for encapsulation.

|            | R                                                                  | JavaScript                                                                    | C#                                                                                |
| ---------- | ------------------------------------------------------------------ | ----------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| Packages   | R Packages (`.tar.gz`)                                             | NPM Packages (`.js`)                                                          | NuGet Packages (`.nupkg`)                                                         |
| Modules    | Naming Convention (`dot.case`), Environments (`new.env()`)         | ES6 Modules (`export`, `import`)                                              | Assemblies (`.dll`), Namespaces (`namespace`, `using`)                            |
| Components | Function Closure (`component <- \(){}`), Classes (`class() <- ''`) | Function Closure (`() => {}`), Classes (`class`), Objects (`{}`)              | Classes (`class`), Structures (`struct`), Access Modifiers (`public`, `internal`) |
| Members    | Not Applicable                                                     | Properties and Methods, `let`, `const` (Public: default, Private: `#` prefix) | Properties and Methods (`private`, `protected`, `public`)                         |

The key take away message from part 1 is that encapsulation is part and parcel of enterprise-level application development. It is used to reduce complexity and increase reusability. But more so it helps teams to break the scope of work associated with building large applications into smaller, more manageable pieces.
